"""
Shared utilities for 0DTE trading applications
Consolidates common functionality between gradio_app.py and ai_trading_analyst.py
"""

import logging
import pandas as pd
import plotly.graph_objects as go
from datetime import datetime
from typing import Optional, Tuple, Dict, Any
import io

# Setup logging
logger = logging.getLogger(__name__)


class ExportUtils:
    """Utilities for exporting data and charts"""
    
    @staticmethod
    def export_dataframe_to_csv(df: pd.DataFrame, prefix: str = "data") -> str:
        """Export DataFrame to CSV file"""
        try:
            if df is None or df.empty:
                return "❌ No data to export. Please run an analysis first."
            
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"{prefix}_{timestamp}.csv"
            
            df.to_csv(filename, index=False)
            return f"✅ Data exported to {filename} ({len(df)} rows)"
        except Exception as e:
            logger.error(f"Error exporting CSV: {e}")
            return f"❌ Error exporting CSV: {str(e)}"
    
    @staticmethod
    def export_plotly_figure(fig: go.Figure, prefix: str = "chart") -> str:
        """Export Plotly figure to PNG or HTML"""
        try:
            if fig is None:
                return "❌ No chart to export. Please create a visualization first."
            
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            # Try PNG export first
            try:
                filename = f"{prefix}_{timestamp}.png"
                fig.write_image(filename, width=1200, height=600, scale=2)
                return f"✅ Chart exported to {filename}"
            except Exception:
                # Fallback to HTML
                filename = f"{prefix}_{timestamp}.html"
                fig.write_html(filename)
                return f"✅ Chart exported to {filename} (install kaleido for PNG: pip install kaleido)"
        except Exception as e:
            logger.error(f"Error exporting chart: {e}")
            return f"❌ Error exporting chart: {str(e)}"
    
    @staticmethod
    def create_html_report(title: str, content: str, chart: Optional[go.Figure] = None) -> str:
        """Create an HTML report with content and optional chart"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"report_{timestamp}.html"
            
            html_content = f"""
            <!DOCTYPE html>
            <html>
            <head>
                <title>{title} - {timestamp}</title>
                <style>
                    body {{ 
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        margin: 40px auto;
                        max-width: 1200px;
                        line-height: 1.6;
                        color: #333;
                    }}
                    h1 {{ color: #2e7d32; margin-bottom: 10px; }}
                    h2 {{ color: #1976d2; margin-top: 30px; }}
                    .timestamp {{ color: #666; font-size: 0.9em; margin-bottom: 20px; }}
                    .content {{ 
                        background-color: #f5f5f5; 
                        padding: 20px; 
                        border-radius: 8px;
                        margin: 20px 0;
                        white-space: pre-wrap;
                        font-family: 'Courier New', monospace;
                    }}
                    .chart {{ margin: 30px 0; }}
                    .footer {{ 
                        margin-top: 40px;
                        padding-top: 20px;
                        border-top: 1px solid #ddd;
                        color: #666;
                        font-size: 0.9em;
                    }}
                </style>
            </head>
            <body>
                <h1>{title}</h1>
                <p class="timestamp">Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
                <div class="content">{content}</div>
            """
            
            if chart is not None:
                chart_html = chart.to_html(include_plotlyjs='cdn', div_id="main-chart")
                html_content += f"""
                <div class="chart">
                    <h2>Visualization</h2>
                    {chart_html}
                </div>
                """
            
            html_content += """
                <div class="footer">
                    <p>Generated by 0DTE Trading Analysis System</p>
                </div>
            </body>
            </html>
            """
            
            with open(filename, 'w') as f:
                f.write(html_content)
            
            return f"✅ Report exported to {filename}"
        except Exception as e:
            logger.error(f"Error creating HTML report: {e}")
            return f"❌ Error creating report: {str(e)}"


class ErrorMessages:
    """Standardized error messages across applications"""
    
    NO_DATA = "❌ Data file not found: {}\n💡 Please run 'python download_spy_data_incremental.py' to download SPY data."
    NO_API_KEY = "❌ OpenAI API key not found!\n💡 Please add OPENAI_API_KEY to your .env file."
    RATE_LIMIT = "❌ OpenAI API rate limit reached!\n💡 Please wait 1-2 minutes and try again.\n💡 Consider using GPT-3.5 for higher rate limits."
    INVALID_REQUEST = "❌ Please enter a valid request.\n💡 Try: '{}'"
    NO_RESULTS = "⚠️ No results found for your query.\n💡 Try:\n  • A different time period\n  • Different parameters\n  • Checking if data exists for that period"
    PORT_IN_USE = "\n❌ Port {} is already in use!\n💡 Try one of these solutions:\n   1. Kill the existing process: {}\n   2. Use a different port\n   3. Wait a moment and try again\n"
    
    @staticmethod
    def format_error(error: Exception, context: str = "") -> str:
        """Format an exception into a user-friendly error message"""
        error_str = str(error).lower()
        
        if "file not found" in error_str:
            return ErrorMessages.NO_DATA.format("data/SPY.parquet")
        elif "api key" in error_str or "authentication" in error_str:
            return ErrorMessages.NO_API_KEY
        elif "rate limit" in error_str or "rate_limit" in error_str:
            return ErrorMessages.RATE_LIMIT
        elif "connection" in error_str or "network" in error_str:
            return "❌ Connection error!\n💡 Please check your internet connection."
        elif "context length" in error_str or "token" in error_str:
            return "❌ Query too complex!\n💡 Try a simpler question or specify a shorter time period."
        else:
            return f"❌ Error in {context}: {str(error)[:200]}...\n💡 Check the logs for more details."


class ChartStyles:
    """Consistent chart styling across applications"""
    
    # Color schemes
    COLORS = {
        'primary': '#1976d2',
        'secondary': '#dc004e',
        'success': '#2e7d32',
        'warning': '#f57c00',
        'bullish': '#10b981',
        'bearish': '#ef4444',
        'neutral': '#6b7280'
    }
    
    # Chart themes
    THEME = 'plotly_white'
    
    @staticmethod
    def apply_standard_layout(fig: go.Figure, title: str, height: int = 600) -> go.Figure:
        """Apply standard layout to a Plotly figure"""
        fig.update_layout(
            title={
                'text': title,
                'font': {'size': 20, 'color': ChartStyles.COLORS['primary']}
            },
            template=ChartStyles.THEME,
            height=height,
            hovermode='x unified',
            showlegend=True,
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="right",
                x=1
            ),
            margin=dict(l=50, r=50, t=80, b=50)
        )
        
        # Update axes
        fig.update_xaxes(
            gridcolor='lightgray',
            gridwidth=0.5,
            showgrid=True
        )
        fig.update_yaxes(
            gridcolor='lightgray',
            gridwidth=0.5,
            showgrid=True
        )
        
        return fig
    
    @staticmethod
    def create_equity_curve(df: pd.DataFrame, title: str = "Equity Curve") -> go.Figure:
        """Create a standard equity curve plot"""
        fig = go.Figure()
        
        # Cumulative P&L
        fig.add_trace(go.Scatter(
            x=df['date'],
            y=df['cumulative_pnl'],
            mode='lines',
            name='Cumulative P&L',
            line=dict(color=ChartStyles.COLORS['primary'], width=2)
        ))
        
        # Add zero line
        fig.add_hline(y=0, line_dash="dash", line_color="gray", opacity=0.5)
        
        # Apply standard layout
        ChartStyles.apply_standard_layout(fig, title)
        fig.update_yaxis(title_text="Cumulative P&L ($)")
        fig.update_xaxis(title_text="Date")
        
        return fig


class DataValidation:
    """Common data validation utilities"""
    
    @staticmethod
    def validate_dataframe(df: pd.DataFrame, required_columns: list) -> Tuple[bool, str]:
        """Validate DataFrame has required columns and data"""
        if df is None:
            return False, "No data provided"
        
        if df.empty:
            return False, "DataFrame is empty"
        
        missing_columns = [col for col in required_columns if col not in df.columns]
        if missing_columns:
            return False, f"Missing required columns: {', '.join(missing_columns)}"
        
        return True, "Valid"
    
    @staticmethod
    def validate_date_range(start_date: Any, end_date: Any) -> Tuple[bool, str]:
        """Validate date range inputs"""
        try:
            if pd.Timestamp(start_date) > pd.Timestamp(end_date):
                return False, "Start date must be before end date"
            return True, "Valid"
        except Exception as e:
            return False, f"Invalid date format: {str(e)}"


class PerformanceMetrics:
    """Common performance calculation utilities"""
    
    @staticmethod
    def calculate_sharpe_ratio(returns: pd.Series, periods_per_year: int = 252) -> float:
        """Calculate Sharpe ratio"""
        if len(returns) < 2:
            return 0.0
        
        mean_return = returns.mean()
        std_return = returns.std()
        
        if std_return == 0:
            return 0.0
        
        return (mean_return / std_return) * (periods_per_year ** 0.5)
    
    @staticmethod
    def calculate_max_drawdown(cumulative_returns: pd.Series) -> Tuple[float, float]:
        """Calculate maximum drawdown and duration"""
        running_max = cumulative_returns.expanding().max()
        drawdown = cumulative_returns - running_max
        
        max_drawdown = drawdown.min()
        
        # Calculate duration
        drawdown_start = drawdown[drawdown == max_drawdown].index[0]
        if max_drawdown < 0:
            recovery_dates = drawdown[drawdown == 0].index
            recovery_dates = recovery_dates[recovery_dates > drawdown_start]
            if len(recovery_dates) > 0:
                drawdown_duration = (recovery_dates[0] - drawdown_start).days
            else:
                drawdown_duration = (drawdown.index[-1] - drawdown_start).days
        else:
            drawdown_duration = 0
        
        return max_drawdown, drawdown_duration
    
    @staticmethod
    def calculate_win_rate_metrics(trades_df: pd.DataFrame) -> Dict[str, float]:
        """Calculate comprehensive win rate metrics"""
        if trades_df.empty:
            return {
                'win_rate': 0,
                'avg_win': 0,
                'avg_loss': 0,
                'profit_factor': 0,
                'expectancy': 0
            }
        
        wins = trades_df[trades_df['pnl'] > 0]
        losses = trades_df[trades_df['pnl'] < 0]
        
        win_rate = len(wins) / len(trades_df) if len(trades_df) > 0 else 0
        avg_win = wins['pnl'].mean() if len(wins) > 0 else 0
        avg_loss = losses['pnl'].mean() if len(losses) > 0 else 0
        
        total_wins = wins['pnl'].sum() if len(wins) > 0 else 0
        total_losses = abs(losses['pnl'].sum()) if len(losses) > 0 else 0
        profit_factor = total_wins / total_losses if total_losses > 0 else 0
        
        expectancy = (win_rate * avg_win) + ((1 - win_rate) * avg_loss)
        
        return {
            'win_rate': win_rate,
            'avg_win': avg_win,
            'avg_loss': avg_loss,
            'profit_factor': profit_factor,
            'expectancy': expectancy,
            'total_trades': len(trades_df),
            'winning_trades': len(wins),
            'losing_trades': len(losses)
        }


# Preset query templates (shared between apps)
PRESET_QUERIES = {
    "Quick ORB Tests": [
        "Test 15-minute ORB for last 30 days",
        "Test 30-minute ORB for last 60 days",
        "Test 60-minute ORB for last 90 days with plot"
    ],
    "Strategy Comparisons": [
        "Compare all ORB timeframes for full period",
        "Compare ORB performance across different instruments",
        "Test ORB vs buy-and-hold strategy"
    ],
    "Advanced Analysis": [
        "Predict tomorrow's volatility using HAR model",
        "Find optimal ORB parameters using walk-forward analysis",
        "Analyze market regime impact on ORB performance"
    ],
    "Risk Analysis": [
        "Calculate maximum drawdown for all strategies",
        "Show risk-adjusted returns comparison",
        "Analyze worst losing streaks"
    ]
}